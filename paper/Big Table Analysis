Motivation:

  The need for a framework that can specify (and generate) domain-specific
  visual IDEs.  We are looking for 1) what features should and should not
  be present and 2) what is the best way of presenting that feature.


Audience:

  + Domain
    - This feature is neutral.  Domain is determined by the developer and
      is completely based on the purpose of the IDE.

  + Skill
    - Because we are focusing on accessibility, aiming towards a general
      skill level would be ideal.  Novice users wouldn't be confused or
      intimidated by the design, and expert users wouldn't feel limited or
      held back.  However, in terms of accessibility, Novice is better than
      intermediate, which is better than expert.


Chrome:

  + Features
    - This is relatively neutral, in that necessary features are often
      determined by the visual language.  In general when dealing with
      visual languages though, Save, Delete, Copy, Cut, Paste, and Undo are
      somewhat important.

  + Context
    - Context sensitive tools are good.  They would be expected by
      non-programmers and further focus the intuitiveness of the IDE.

  + ToolRichness
    - A high degree of interface visual richness is definitely a good
      thing.  The more methods the IDE uses to differentiate the tools, the
      easier it is for the user to discern the different tools.

  + Perspectives
    - A larger amount of Perspectives is better than a smaller amount.
      Different perspectives can allow different visualizations of the same
      thing, well-adhering to various working styles that a wide range of
      users would have.  They also support modularization, making the IDE
      more manageable.

  + Properties
    -

  + Searchable
    -

  + ToolStyle
    -

  + Clutter
    -


Human Interface:

  + EEfficiency
    -

  + IEfficiency
    -

  + Keyboard
    -

  + Mode
    - This feature can have a bidirectional effect on the goal. The most
      common mode, "Drag n Drop (1:1)", is standard and A-OK. The mode
      "Point n Click (1:1)" is slightly less common than this, but just as
      productive overall. A slightly more productive mode, "Point n Click
      (1:n)", is less common but probably better good given that it allows
      for faster creation of elements.

  + Devices
    - This feature is NEUTRAL. While being able to interface with multiple
      devices might be beneficial at times, depending on the domain it
      might not even be feasible. Cannot be expected as a feature of an
      IDE.


Integration:

  + Relations
    - This feature is POSITIVE. While not having this feature is not
      necessarily a bad thing, having it aids the user by quickly
      indicating what actions are allowed to them.

  + Output
    - This feature is neutral and can't really have an effect toward the
      goal. Direct / Indirect isn't a good/bad mapping. Live/Trigger can
      also both be good or bad.

  + Syntax
    - This feature is POSITIVE. Implicit syntax enforcement is the best,
      followed by explicit, followed by no syntax enforcement at all.
      Implicit syntax reduces the amount of load placed on the user by
      reducing the number of available actions to a small set of legal
      actions.  Explicit enforcement requires the user to go back and make
      changes if he/she creates an error. Having no syntax enforcement at all
      is simply dangerous and does not help the user. It's neutral, though,
      because syntax enforcement can't really be entirely expected.


Language Syntax:

  + Complexity
    - This feature is POSITIVE. Complexity is bad, managing it is good.
      Tools for complexity management help reduce user mental load.

  + Connection
    - This feature is NEUTRAL and has no real effect toward the goal. It
      simply provides a classification scheme for the language types.

  + LanguageRichness
    - Like ToolRichness, having a higher amount of variables acting toward
      LanguageRichness is a good thing. A higher amount of visual
      discriminability results in an easier time for the user to
      differentiate elements on the screen.
