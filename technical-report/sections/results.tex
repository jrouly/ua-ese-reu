\section{Results}
\label{sec:results}


\paragraph{Alice3} Designed primarily as an educational programming
environment, Alice3 alienates skilled users by expecting a lower level of
skill in its domain. It makes up for this loss in accessibility, however,
with its wide, almost universal, support of common \ac{ide} features as
well as context-sensitive tooling. Alice3 provides a medium level of visual
richness in its interface chrome, but boasts one of the highest essential
efficiency values. This efficiency value is achieved through the ``MIT
Scratch'' style of visual syntax. However, despite greatly reducing
operator mental load, Alice3's clunky design only manages a near-neutral
interface efficiency. The introduction of optional keybindings is a
redeeming factor for Alice3 and, like most educational programming
\acp{ide}, Alice3 includes simple modular complexity management and a
visually appealing level of language visual richness.

\paragraph{AToMPM}

\paragraph{AudioMulch} Although AudioMulch offers a wide array of tools and
an in-depth interface ideal for professionals in the music industry, the
overall complexity of the design greatly reduces the accessibility for
anyone else. It supports a large amount of popular \ac{ide} features,
however, and offers equally high essential and interface efficiency
ratings. This is visually assisted by a relation-highlighting feature
which also provides AudioMulch with an implicit syntax enforcement, both of
which greatly aid the user in model creation. Unfortunately, there is no
effort made to manage the high amount of complexity within the \ac{ide} and
virtually all of the canvas elements look exactly the same, ultimately
awarding AudioMulch with a low language visual richness score.

\paragraph{Blender} Designed for a skilled target audience of experts in
the domain, it is no surprise that Blender supports most common \ac{ide}
features or provides context-sensitive tooling. Its high level of chrome
visual richness and the large number of perspectives available relative to
the average found in this study also contribute to a high quality
interface. However, its featurefulness leads directly to the second highest
observed value for visual clutter. Blender possess no particular efficiency
techniques, remaining around a perfect one-to-one relationship with the
measured essential use cases. Its heavy use of the keyboard reduces
accessibility to a wider audience, although the target skill level is
already a limiting factor. Finally, Blender provides modularization
complexity management through saving and duplication tools,along with one
of the most visually rich languages observed.

\paragraph{Cameleon}

\paragraph{\acl{emf}}

\paragraph{\acl{grc}}

\paragraph{Grasshopper 3D} Though Grasshopper is able to provide the user
with a relatively simple and easy to use interface, beginners would likely
shy away from the complexity of its core functionality. Even so, it offers
a high amount of popular \ac{ide} features and context sensitive tools, as
well as the ability to search through its vast library of tools quickly and
easily by name. Grasshopper also possesses very good efficiency techniques,
maintaining both values at a more-than-decent level. In addition, the
optional use of a keyboard is supported, offering functionality on another
level to increase accessibility. Complexity management is not supported at
all, however, and visual richness in both the language and tools are
mediocre at best.

\paragraph{Max}

\paragraph{MetaEdit+} Aimed towards an intermediate level of users, the many different tasks and steps that go into the design of a simple model in MetaEdit+ can easily be daunting for newer users.  These tasks are fortunately divided through modularization, allowing them to be much more manageable withing the \ac{ide}. Furthermore, many of the popular \ac{ide} features as well as context sensitive tools are present in the interface, increasing the accessability even more. MetaEdit+ also holds the lowest clutter value and integrates an inplicit syntax enforcement, providing the user with a clear and easy-to-use workspace. A favorable essential efficiency value is also present, whereas the interface efficiency suffers from MetaEdit+'s necessity to complete a dialog for each created element.

\paragraph{MIT AppInventor} Much like Alice3 and the other educational
interfaces, MIT's AppInventor is designed for an unskilled, novice
audience, reducing the breadth of target audience. By only supporting three
of the top ten popular features, AppInventor additionally alienates its
audience through nonconformity with expected standards. While colorful,
AppInventor's interface only supports four visual variables to distinguish
elements in the chrome, relying heavily on icons and text. AppInventor
combines the ``MIT Scratch'' style of visual syntax along with a Drag n
Drop element creation workspace, resulting in high levels of effective and
interface efficiency. Another artifact of the ``MIT Scratch'' style of
visual syntax is its implicit syntax enforcement, assisting the user by
preventing illegal structures. Finally, the high level of language visual
richness and modular complexity management scheme result in an overall
visually pleasant experience.

\paragraph{MST Workshop} Though MST Workshop offers a very simple and easy-to-use interface, it does not offer much explanation as to the use of its many different simulation categories. As such, they are virtually unusable by anyone without prior knowledge of that subject, drastically limiting its accessibility. In the same vein, it does not incorporate enough visual richness variables to easily discern or interpret the tools and very few popular \ac{ide} features are supported. Though the efficiency values are better than decent and the clutter was rated to be relatively low, no actions were made to reduce the complexity of the system or even enforce the language's syntax. All of this merged together with a less-than-stellar language visual richness level shows that MST Workshop definitely has room for improvement.

\paragraph{Piet Creator} As the primary \ac{ide} used in the creation of Piet programs, Piet Creator does a very good job of providing a very simple interface for novices without limiting the usability for more expert users. On top of that, the toolbars utilize seven of the eight tool visual richness variables and it possesses an extremely low clutter rating, maximizing accessibility for all users.  However, Piet Creator does not offer any sort of properties dialog, eliminating the ability to manage data on a deeper level.  The user is also limited to using only the mouse for every task, which creates a poor combination with the fact that Piet Creator holds the lowest interface efficiency value. The Piet language syntax is not enforced in the slightest, forcing the user to manually debug his/her whole program to located any errors in the code. In general, the simplicity of Piet Creator's design allows for a relaxed and visually appealing enviornment, but it can evidently be overly threadbare to a degrading extent. 

\paragraph{Scratch} One of the earliest educational interfaces present in
this study, Scratch has influenced a great deal of later \acp{ide},
including Stencyl, AppInventor, and Alice3 to name a few. Scratch is
specifically targeted toward a novice audience with a low skill level, and
only supports three of the top ten popular features. The interface employs
an average level of visual richness variables, and does not even define an
object properties window. The sparse, cluttered interface redeems itself
through high values of essential and interface efficiency. Implicit syntax
enforcement provides a safe environment for learning users, and the highest
observed level of language visual richness provides an engaging, visually
rich display. The focus on efficiency and visual richness works well in an
\ac{ide} designed for education by accelerating reinforcement and engaging
student attention.

\paragraph{Simulink}

\paragraph{Stencyl}

\paragraph{Tersus}

\paragraph{TouchDevelop}

\paragraph{UMLet} UMLet provides a general purpose, easy to use software
interface with no particular expectations about user skill level. It offers
many of the most popular \ac{ide} features a user might expect, but does
not offer a visually rich chrome or language. Conceptually efficient but
clunky in implementation, UMLet measured high in essential efficiency but
low in interface efficiency. To the detriment of the inexperienced user,
UMLet offers no syntax enforcement. It also offers no complexity management
devices to ease mental load. Barebones to the extreme, UMLet provides users
with a visually simple interface and no additional usability features like
context-sensitive tooling or searchable tools. Its power, however, lies in
its simplicity and ease of use at any entry skill level.

\paragraph{Violet} Similar to UMLet, Violet provides an easy to use
interface with no specific entry skill level assumptions. It offers the
same common \ac{ide} features as UMLet, with a slightly richer chrome.
Violet's interface is slightly less cluttered than UMLet's but also offers
a lower essential efficiency. Violet is higher in interface efficiency over
UMLet, though. Neither interface offers syntax enforcement or complexity
management and, since both support UML as the target visual language, both
share a low level of language visual richness. The two interfaces are
relatively featureless and differ primarily in the mode of user
interaction.

\paragraph{VisSim}

\paragraph{Visual Paradigm}

\paragraph{Visual Use Case}

\paragraph{WebRatio}

\paragraph{YAWL}

