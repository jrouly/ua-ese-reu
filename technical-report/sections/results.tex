\section{Results}
\label{sec:results}


\paragraph{Alice3} Designed primarily as an educational programming
environment, Alice3 alienates skilled users by expecting a lower level of
skill in its domain. It makes up for this loss in accessibility, however,
with its wide, almost universal, support of common \ac{ide} features as
well as context-sensitive tooling. Alice3 provides a medium level of visual
richness in its interface chrome, but boasts one of the highest essential
efficiency values. This efficiency value is achieved through the ``MIT
Scratch'' style of visual syntax. However, despite greatly reducing
operator mental load, Alice3's clunky design only manages a near-neutral
interface efficiency. The introduction of optional keybindings is a
redeeming factor for Alice3 and, like most educational programming
\acp{ide}, Alice3 includes simple modular complexity management and a
visually appealing level of language visual richness.

\paragraph{AToMPM}

\paragraph{AudioMulch} Although AudioMulch offers a wide array of tools and
an in-depth interface ideal for professionals in the music industry, the
overall complexity of the design greatly reduces the accessibility for
anyone else. It supports a large amount of popular \ac{ide} features,
however, and offers equally high essential and interface efficiency
ratings. This is visually assisted by a relation-highlighting feature
which also provides AudioMulch with an implicit syntax enforcement, both of
which greatly aid the user in model creation. Unfortunately, there is no
effort made to manage the high amount of complexity within the \ac{ide} and
virtually all of the canvas elements look exactly the same, ultimately
awarding AudioMulch with a low language visual richness score.

\paragraph{Blender} Designed for a skilled target audience of experts in
the domain, it is no surprise that Blender supports most common \ac{ide}
features or provides context-sensitive tooling. Its high level of chrome
visual richness and the large number of perspectives available relative to
the average found in this study also contribute to a high quality
interface. However, its featurefulness leads directly to the second highest
observed value for visual clutter. Blender possess no particular efficiency
techniques, remaining around a perfect one-to-one relationship with the
measured essential use cases. Its heavy use of the keyboard reduces
accessibility to a wider audience, although the target skill level is
already a limiting factor. Finally, Blender provides modularization
complexity management through saving and duplication tools,along with one
of the most visually rich languages observed.

\paragraph{Cameleon} Intended for rapid, flexible visual prototyping of
functional algorithms, Cameleon is relatively feature impoverished --- it
only supports three of the most popular \ac{ide} features. It does however
boast a large number of available tools which are conveniently searchable.
Cameleon's interface chrome employs five visual richness variables,
slightly above the average count. Its sleek, simple interface is rated as
low clutter, and provides a positive level of essential and interface
efficiency. Interaction requires use of the keyboard for non-essential
actions, specifically advanced navigation and zooming. Cameleon supports
the user by interactively highlighting allowed syntactic relations and
explicitly enforcing syntax requirements. More support is provided by its
hierarchical complexity management system. Overall, Cameleon is an
efficient, simple tool with a large library of functionality and a focus on
supporting syntax requirements.

\paragraph{\acl{emf}} The \ac{emf} is one of the most sophisticated
\acp{ide} in this study and demands an expert level of skill from target
users. It is also the only \ac{ide} studied which supports all of the
measured popular features, as any expert in the domain would likely come to
expect. The \ac{emf} interface chrome supports five visual richness
variables as well as a large number of predefined interface perspectives.
The high level of supported perspectives, while perhaps intimidating,
increases the overall power and utility of the interface. Additionally, the
\ac{emf} tool space is searchable, which counterbalances the highest
observed level of visual clutter. Despite being extremely cluttered,
\ac{emf} has average levels of essential efficiency and the highest
measured level of interface efficiency. The supported visual languages do
not make use of more than five visual variables but do allow for complexity
management. Overall, \ac{emf} is well suited for an expert user with high
efficiency and several convenience features, but is too cluttered and not
visually rich enough to support a wider audience of varied skill levels.

\paragraph{\acl{grc}} \acl{grc} is a simple platform designed to aid the
development of signal processing software without the need to understand or
write code. It does, however, require a moderate level of skill in the
domain. \ac{grc} supports slightly more than the average number of popular
\ac{ide} features as well as the ability to search through available tools.
\ac{grc} is not extensively visually pleasing, however, as the interface
chrome only utilizes four visual variables while the supported language
only employs two. Despite this, the interface is highly efficient, with the
highest observed interface efficiency and a correspondingly high level of
essential efficiency. It also supports some optional keyboard use and
explicit syntax checking. \ac{grc} is designed as an easy to use interface
for non-coders, and manages to maintain simplicity while still offering a
large amount of technical power.

\paragraph{Grasshopper 3D} Though Grasshopper is able to provide the user
with a relatively simple and easy to use interface, beginners would likely
shy away from the complexity of its core functionality. Even so, it offers
a high amount of popular \ac{ide} features and context sensitive tools, as
well as the ability to search through its vast library of tools quickly and
easily by name. Grasshopper also possesses very good efficiency techniques,
maintaining both values at a more-than-decent level. In addition, the
optional use of a keyboard is supported, offering functionality on another
level to increase accessibility. Complexity management is not supported at
all, however, and visual richness in both the language and tools are
mediocre at best.

\paragraph{Max}

\paragraph{MetaEdit+} Aimed towards an intermediate level of users, the
many different tasks and steps that go into the design of a simple model in
MetaEdit+ can easily be daunting for newer users.  These tasks are
fortunately divided through modularization, allowing them to be much more
manageable withing the \ac{ide}. Furthermore, many of the popular \ac{ide}
features as well as context sensitive tools are present in the interface,
increasing the accessability even more. MetaEdit+ also holds the lowest
clutter value and integrates an inplicit syntax enforcement, providing the
user with a clear and easy to use workspace. A favorable essential
efficiency value is also present, whereas the interface efficiency suffers
from MetaEdit+'s necessity to complete a dialog for each created element.

\paragraph{MIT AppInventor} Much like Alice3 and the other educational
interfaces, MIT's AppInventor is designed for an unskilled, novice
audience, reducing the breadth of target audience. By only supporting three
of the top ten popular features, AppInventor additionally alienates its
audience through nonconformity with expected standards. While colorful,
AppInventor's interface only supports four visual variables to distinguish
elements in the chrome, relying heavily on icons and text. AppInventor
combines the ``MIT Scratch'' style of visual syntax along with a Drag n
Drop element creation workspace, resulting in high levels of effective and
interface efficiency. Another artifact of the ``MIT Scratch'' style of
visual syntax is its implicit syntax enforcement, assisting the user by
preventing illegal structures. Finally, the high level of language visual
richness and modular complexity management scheme result in an overall
visually pleasant experience.

\paragraph{MST Workshop} Though MST Workshop offers a very simple and
easy to use interface, it does not offer much explanation as to the use of
its many different simulation categories. As such, they are virtually
unusable by anyone without prior knowledge of that subject, drastically
limiting its accessibility. In the same vein, it does not incorporate
enough visual richness variables to easily discern or interpret the tools
and very few popular \ac{ide} features are supported. Though the efficiency
values are better than decent and the clutter was rated to be relatively
low, no actions were made to reduce the complexity of the system or even
enforce the language's syntax. All of this merged together with a
less-than-stellar language visual richness level shows that MST Workshop
definitely has room for improvement.

\paragraph{Piet Creator} As the primary \ac{ide} used in the creation of
Piet programs, Piet Creator does a very good job of providing a very simple
interface for novices without limiting the usability for more expert users.
On top of that, the toolbars utilize seven of the eight tool visual
richness variables and it possesses an extremely low clutter rating,
maximizing accessibility for all users.  However, Piet Creator does not
offer any sort of properties dialog, eliminating the ability to manage data
on a deeper level. The user is also limited to using only the mouse for
every task, which creates a poor combination with the fact that Piet
Creator holds the lowest interface efficiency value. The Piet language
syntax is not enforced in the slightest, forcing the user to manually debug
his/her whole program to located any errors in the code. In general, the
simplicity of Piet Creator's design allows for a relaxed and visually
appealing environment, but it can evidently be overly threadbare to a
degrading extent.

\paragraph{Scratch} One of the earliest educational interfaces present in
this study, Scratch has influenced a great deal of later \acp{ide},
including Stencyl, AppInventor, and Alice3 to name a few. Scratch is
specifically targeted toward a novice audience with a low skill level, and
only supports three of the top ten popular features. The interface employs
an average level of visual richness variables, and does not even define an
object properties window. The sparse, cluttered interface redeems itself
through high values of essential and interface efficiency. Implicit syntax
enforcement provides a safe environment for learning users, and the highest
observed level of language visual richness provides an engaging, visually
rich display. The focus on efficiency and visual richness works well in an
\ac{ide} designed for education by accelerating reinforcement and engaging
student attention.

\paragraph{Simulink} Though Simulink features a plethora of components that
can allow it to perform virtually any electrical simulation, the vast scope
of its functions and the amount of on-screen tasks greatly reduces its
accessibility. Each individual function that Simulink provides creates its
own dialog window on screen, severely increasing visual clutter and
complexity with prolonged use and no techniques for complexity management.
A searchable toolspace is present to take off some mental load in dealing
with Simulink's huge tool libraries, however very few visual richness
variables are integrated to increase discernibility between the tools. The
canvas elements also provide some relatively good efficiency values, though
the \ac{ide} provides no features to enforce the syntax of the simulation
language. The lack of visual richness overall detracts from the usability
and enjoyment of this tool, despite it being very powerful.

\paragraph{Stencyl} Stencyl provides a very easy to use interface for game software creation for an early level audience, but in the process sacrifices any higher level functionality. This \ac{ide} also integrates the ``MIT Scratch'' style of coding, which carries along with it very high efficiency values and implicit syntax enforcement. Every tool visual richness variable is utilized within the toolbars, which are also searchable, allowing for a very user-friendly and productive interface. Each language visual richness variable is supported within the canvas as well, thereby giving Stencyl perfect visual richness ratings. A very large number of perspectives are present due to Stencyl's powerful modularization techniques, greatly reduicng the amount of mental strain on the user to handle the many steps that go into creating a game and showing Stencyl to be an altogether organized and well-designed \ac{ide}.

\paragraph{Tersus}

\paragraph{TouchDevelop}

\paragraph{UMLet} UMLet provides a general purpose, easy to use software
interface with no particular expectations about user skill level. It offers
many of the most popular \ac{ide} features a user might expect, but does
not offer a visually rich chrome or language. Conceptually efficient but
clunky in implementation, UMLet measured high in essential efficiency but
low in interface efficiency. To the detriment of the inexperienced user,
UMLet offers no syntax enforcement. It also offers no complexity management
devices to ease mental load. Barebones to the extreme, UMLet provides users
with a visually simple interface and no additional usability features like
context-sensitive tooling or searchable tools. Its power, however, lies in
its simplicity and ease of use at any entry skill level.

\paragraph{Violet} Similar to UMLet, Violet provides an easy to use
interface with no specific entry skill level assumptions. It offers the
same common \ac{ide} features as UMLet, with a slightly richer chrome.
Violet's interface is slightly less cluttered than UMLet's but also offers
a lower essential efficiency. Violet is higher in interface efficiency over
UMLet, though. Neither interface offers syntax enforcement or complexity
management and, since both support UML as the target visual language, both
share a low level of language visual richness. The two interfaces are
relatively featureless and differ primarily in the mode of user
interaction.

\paragraph{VisSim}

\paragraph{Visual Paradigm}

\paragraph{Visual Use Case}

\paragraph{WebRatio}

\paragraph{YAWL}

